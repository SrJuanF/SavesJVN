{
  "language": "Solidity",
  "sources": {
    "contracts/ICeloStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n//********0x907f5C53C0E31dB06aF45BC58F076563469c525a********\r\ninterface CeloStakingAccount {\r\n    function createAccount() external returns (bool);\r\n}\r\n\r\n//*********0x55E1A0C8f376964bd339167476063bFED7f213d5**********\r\ninterface CeloStakingGold{\r\n    // Si hay parte en unlocking\r\n    function relock(uint256, uint256) external;\r\n    //Si revierte, despues se intenta con lock, locks nuevos\r\n    function lock() external payable;\r\n    \r\n    function unlock(uint256) external;\r\n}\r\n\r\n//*********0xbD7d392BB2eF07063256E875f363d4fb2931780e***********\r\ninterface CeloStakingElection{\r\n    /*\r\n    0\tgroup\taddress\r\n0xd42Bb7FE32cDf68045f49553c6f851fD2c58B6a9\r\n1\tvalue\tuint256 => digita usuario\r\n2\tlesser\taddress\r\n0xb35Be22BccB0dB9dC62967dcF15fEB97C20f854e\r\n3\tgreater\taddress\r\n0x2fd49E97262D505Fd76BB6E0e06eC10e1fd54589\r\n     */\r\n    //\"Staking\"\r\n    function vote(\r\n        address group,\r\n        uint256 value,\r\n        address lesser,\r\n        address greater\r\n    ) external returns (bool);\r\n\r\n    //Primero revokePending, si acabo de stakear\r\n    function revokePending(\r\n        address group,\r\n        uint256 value,\r\n        address lesser,\r\n        address greater,\r\n        uint256 index\r\n    ) external returns (bool);\r\n    //Si revierte, despues se intenta con revokeActive, si ya lleva tiempo en Staking\r\n    function revokeActive(\r\n        address group,\r\n        uint256 value,\r\n        address lesser,\r\n        address greater,\r\n        uint256 index\r\n    ) external returns (bool);\r\n}\r\n\r\n//0xBE729350F8CdFC19DB6866e8579841188eE57f67\r\ninterface swapcCopCelo{\r\n\r\n    /*\r\n1\tamountIn\tuint256 => digita usuario\r\n2\tamountOutMin\tuint256 => digita usaurio\r\n2\tpath.exchangeProvider\taddress\r\n0x22d9db95E6Ae61c104A7B6F6C78D7993B94ec901\r\n2\tpath.exchangeId\tbytes32\r\n0x1c9378bd0973ff313a599d3effc654ba759f8ccca655ab6d6ce5bd39a212943b\r\n2\tpath.assetIn\taddress\r\n0x8A567e2aE79CA692Bd748aB832081C45de4041eA\r\n2\tpath.assetOut\taddress\r\n0x765DE816845861e75A25fCA122bb6898B8B1282a\r\n3\tpath.exchangeProvider\taddress\r\n0x22d9db95E6Ae61c104A7B6F6C78D7993B94ec901\r\n3\tpath.exchangeId\tbytes32\r\n0x3135b662c38265d0655177091f1b647b4fef511103d06c016efdf18b46930d2c\r\n3\tpath.assetIn\taddress\r\n0x765DE816845861e75A25fCA122bb6898B8B1282a\r\n3\tpath.assetOut\taddress\r\n0x471EcE3750Da237f93B8E339c536989b8978a438\r\n */\r\n\r\n    /// @notice Structure defining a single step in the swap path\r\n    /// @param exchangeProvider The address of the exchange provider\r\n    /// @param exchangeId The unique identifier for the exchange\r\n    /// @param assetIn The address of the input asset\r\n    /// @param assetOut The address of the output asset\r\n    struct Step {\r\n        address exchangeProvider;\r\n        bytes32 exchangeId;\r\n        address assetIn;\r\n        address assetOut;\r\n    }\r\n\r\n    /// @notice Swap an exact amount of input tokens for as many output tokens as possible\r\n    /// @param amountIn The amount of input tokens to swap\r\n    /// @param amountOutMin The minimum amount of output tokens that must be received\r\n    /// @param path An array of Step structs defining the swap path\r\n    /// @return amounts The amounts of tokens for each step in the path\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        Step[] calldata path\r\n    ) external returns (uint256[] memory amounts);\r\n}\r\n\r\n//0x434563B0604BE100F04B7Ae485BcafE3c9D8850E\r\ninterface cCopToken{\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n}"
    },
    "contracts/IDAppStaking.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// Predeployed at the address 0x0000000000000000000000000000000000005001\r\n/// For better understanding check the source code:\r\n/// repo: https://github.com/AstarNetwork/Astar\r\n/// code: pallets/dapp-staking\r\ninterface DAppStaking {\r\n\r\n    // Types\r\n\r\n    /// Describes the subperiod in which the protocol currently is.\r\n    enum Subperiod {Voting, BuildAndEarn}\r\n\r\n    /// Describes current smart contract types supported by the network.\r\n    enum SmartContractType {EVM, WASM}\r\n\r\n    /// @notice Describes protocol state.\r\n    /// @param era: Ongoing era number.\r\n    /// @param period: Ongoing period number.\r\n    /// @param subperiod: Ongoing subperiod type.\r\n    struct ProtocolState {\r\n        uint256 era;\r\n        uint256 period;\r\n        Subperiod subperiod;\r\n    }\r\n\r\n    /// @notice Used to describe smart contract. Astar supports both EVM & WASM smart contracts\r\n    ///         so it's important to differentiate between the two. This approach also allows\r\n    ///         easy extensibility in the future.\r\n    /// @param contract_type: Type of the smart contract to be used\r\n    struct SmartContract {\r\n        SmartContractType contract_type;\r\n        bytes contract_address;\r\n    }\r\n\r\n    // Storage getters\r\n\r\n    /// @notice Get the current protocol state.\r\n    /// @return (current era, current period number, current subperiod type).\r\n    function protocol_state() external view returns (ProtocolState memory);\r\n\r\n    /// @notice Get the unlocking period expressed in the number of blocks.\r\n    /// @return period: The unlocking period expressed in the number of blocks.\r\n    function unlocking_period() external view returns (uint256);\r\n\r\n\r\n    // Extrinsic calls\r\n\r\n    /// @notice Lock the given amount of tokens into dApp staking protocol.\r\n    /// @param amount: The amount of tokens to be locked.\r\n    function lock(uint128 amount) external returns (bool);\r\n\r\n    /// @notice Start the unlocking process for the given amount of tokens.\r\n    /// @param amount: The amount of tokens to be unlocked.\r\n    function unlock(uint128 amount) external returns (bool);\r\n\r\n    /// @notice Claims unlocked tokens, if there are any\r\n    function claim_unlocked() external returns (bool);\r\n\r\n    /// @notice Stake the given amount of tokens on the specified smart contract.\r\n    ///         The amount specified must be precise, otherwise the call will fail.\r\n    /// @param smart_contract: The smart contract to be staked on.\r\n    /// @param amount: The amount of tokens to be staked.\r\n    function stake(SmartContract calldata smart_contract, uint128 amount) external returns (bool);\r\n\r\n    /// @notice Unstake the given amount of tokens from the specified smart contract.\r\n    ///         The amount specified must be precise, otherwise the call will fail.\r\n    /// @param smart_contract: The smart contract to be unstaked from.\r\n    /// @param amount: The amount of tokens to be unstaked.\r\n    function unstake(SmartContract calldata smart_contract, uint128 amount) external returns (bool);\r\n\r\n    /// @notice Move the given amount of tokens from the specified source contract to the specified destination contract.\r\n    ///         The amount specified must be precise, otherwise the call will fail.\r\n    /// @param source_contract: The source smart contract to be moved from.\r\n    /// @param destination_contract: The destination smart contract to be moved on.\r\n    /// @param amount: The amount of tokens to be moved.\r\n    function move_stake(SmartContract calldata source_contract, SmartContract calldata destination_contract, uint128 amount) external returns (bool);\r\n\r\n    /// @notice Claims one or more pending staker rewards.\r\n    function claim_staker_rewards() external returns (bool);\r\n\r\n    /// @notice Claim the bonus reward for the specified smart contract.\r\n    /// @param smart_contract: The smart contract for which the bonus reward should be claimed.\r\n    function claim_bonus_reward(SmartContract calldata smart_contract) external returns (bool);\r\n\r\n    /// @notice Claim dApp reward for the specified smart contract & era.\r\n    /// @param smart_contract: The smart contract for which the dApp reward should be claimed.\r\n    /// @param era: The era for which the dApp reward should be claimed.\r\n    function claim_dapp_reward(SmartContract calldata smart_contract, uint256 era) external returns (bool);\r\n\r\n    /// @notice Unstake all funds from the unregistered smart contract.\r\n    /// @param smart_contract: The smart contract which was unregistered and from which all funds should be unstaked.\r\n    function unstake_from_unregistered(SmartContract calldata smart_contract) external returns (bool);\r\n\r\n    /// @notice Used to cleanup all expired contract stake entries from the caller.\r\n    function cleanup_expired_entries() external returns (bool);\r\n}"
    },
    "contracts/SavesJVN.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"./IDAppStaking.sol\";\n\n/**\n * @title SavesJVN\n * @notice Contrato para fondos de ahorro con soporte multi-red:\n *  - En Celo: depósitos con token ERC20 (cCOP)\n *  - En Astar: depósitos con moneda nativa (ASTR) y \"staking\" contable con penalización por tiempo\n *\n * Importante: El \"staking\" aquí es interno del contrato (contable), no interactúa con el sistema de dApp staking de Astar.\n */\ncontract SavesJVN {\n    error InvalidArrayLength();\n    error InvalidFundTypeDuration();\n    error NotOwnerOrPrivileged();\n    error NotPrivileged();\n    error NotBeneficiary();\n    error FundNotActive();\n    error FundNotFound();\n    error NotMatured();\n    error TokenRequired();\n    error NativeRequired();\n    error AmountExceedsAvailable();\n    error OnlyOwner();\n    error NativeTransferFailed();\n    error TokenTransferFailed();\n    error DappTargetNotSet();\n\n    enum FundType {\n        PensionVoluntaria,\n        AhorroUniversitario\n    }\n\n    struct Fund {\n        FundType fundType;\n        address owner;\n        uint64 startTime;\n        uint64 endTime; // timestamp de finalización\n        address[4] privileged; // wallets con privilegio (staking y retiro al cumplir tiempo)\n        address[4] beneficiaries; // wallets beneficiarias\n        uint256 balance; // saldo total del fondo (depósitos - retiros + retornos de staking)\n        uint256 stakedBalance; // saldo \"en staking\" contable\n        address dappTarget;\n        bool active;\n    }\n\n    // Token ERC20 usado para depósitos en Celo. Si es address(0), el contrato opera en modo \"nativo\" (ASTR en Astar)\n    address public immutable token;\n    address private immutable Owner;\n    // Penalización de tiempo (en segundos) aplicada según reglas de negocio (p.e. 6 meses)\n    uint64 public immutable penaltyDuration;\n\n    uint256 public nextFundId;\n    mapping(uint256 => Fund) public funds;\n\n    // Mapea un usuario (wallet) a los IDs de fondos en los que participa\n    // como \"privileged\" o \"beneficiary\".\n    mapping(address => uint256[]) private fundsByUser;\n    // Ayuda a evitar duplicados cuando un usuario aparece en ambas listas.\n    mapping(address => mapping(uint256 => bool)) private userInFund;\n\n    // Dirección del precompile DApps Staking V3 (Astar/Shibuya)\n    address constant DAPPS_STAKING_V3 =\n        0x0000000000000000000000000000000000005001;\n\n    event FundCreated(\n        uint256 indexed fundId,\n        FundType fundType,\n        address indexed owner,\n        uint64 startTime,\n        uint64 endTime\n    );\n    event Deposited(\n        uint256 indexed fundId,\n        address indexed from,\n        uint256 amount,\n        bool native\n    );\n    event Staked(address indexed user, uint256 indexed fundId, uint256 amount);\n    event Unstaked(\n        address indexed user,\n        uint256 indexed fundId,\n        uint256 amount,\n        uint256 penalty\n    );\n    event Withdrawn(\n        address indexed user,\n        uint256 indexed fundId,\n        address indexed to,\n        uint256 amount\n    );\n\n    modifier onlyOwner() {\n        if (msg.sender != Owner) revert OnlyOwner();\n        _;\n    }\n\n    constructor(address tokenAddress, uint64 _penaltyDurationSeconds) {\n        token = tokenAddress;\n        penaltyDuration = _penaltyDurationSeconds;\n        Owner = msg.sender;\n    }\n\n    // -------- Helpers --------\n    function _isInArray(\n        address[4] memory arr,\n        address who\n    ) internal pure returns (bool) {\n        for (uint8 i = 0; i < 4; i++) {\n            if (arr[i] == who) return true;\n        }\n        return false;\n    }\n\n    function _sendTokens(address to, uint256 amount) external onlyOwner {\n        if (token == address(0)) {\n            // Enviar ASTR nativa\n            (bool ok, ) = to.call{value: amount}(\"\");\n            if (!ok) revert NativeTransferFailed();\n        } else {\n            // Enviar token ERC20\n            (bool ok, ) = token.call(\n                abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount)\n            );\n            if (!ok) revert TokenTransferFailed();\n        }\n    }\n\n    // -------- Creación de fondos --------\n    /**\n     * @notice Crea un nuevo fondo con parámetros de tipo y duración.\n     * @param fundType PensionVoluntaria o AhorroUniversitario\n     * @param durationSeconds Duración en segundos (mín. 5 años en segundos para PensionVoluntaria, sin mínimo para AhorroUniversitario)\n     * @param privilegedWallets Hasta 4 wallets con privilegio\n     * @param beneficiaryWallets Hasta 4 wallets beneficiarias\n     */\n    function createFund(\n        FundType fundType,\n        uint64 durationSeconds,\n        address[4] calldata privilegedWallets,\n        address[4] calldata beneficiaryWallets\n    ) external returns (uint256 fundId) {\n        if (privilegedWallets.length > 4 || beneficiaryWallets.length > 4) {\n            revert InvalidArrayLength();\n        }\n        // Para PensionVoluntaria se requiere mínimo 5 años expresados en segundos\n        if (\n            fundType == FundType.PensionVoluntaria &&\n            durationSeconds < uint64(5 * 365 days)\n        ) {\n            revert InvalidFundTypeDuration();\n        }\n\n        uint64 start = uint64(block.timestamp);\n        uint64 end;\n        // Para pruebas: permitir duración corta (15 minutos) cuando fundType es AhorroUniversitario y durationSeconds == 0\n        if (fundType == FundType.AhorroUniversitario && durationSeconds == 0) {\n            end = start + uint64(5 minutes);\n        } else {\n            end = start + durationSeconds;\n        }\n\n        fundId = nextFundId++;\n        Fund storage f = funds[fundId];\n        f.fundType = fundType;\n        f.owner = msg.sender;\n        f.startTime = start;\n        f.endTime = end;\n        f.privileged = privilegedWallets;\n        f.beneficiaries = beneficiaryWallets;\n        f.active = true;\n\n        // Registrar relación usuario-fondo para privilegiados y beneficiarios\n        for (uint256 i = 0; i < privilegedWallets.length; i++) {\n            address u = privilegedWallets[i];\n            if (u != address(0) && !userInFund[u][fundId]) {\n                userInFund[u][fundId] = true;\n                fundsByUser[u].push(fundId);\n            }\n        }\n        for (uint256 j = 0; j < beneficiaryWallets.length; j++) {\n            address u2 = beneficiaryWallets[j];\n            if (u2 != address(0) && !userInFund[u2][fundId]) {\n                userInFund[u2][fundId] = true;\n                fundsByUser[u2].push(fundId);\n            }\n        }\n\n        emit FundCreated(fundId, fundType, msg.sender, start, end);\n    }\n\n    /**\n     * @notice Configura el contrato dApp EVM objetivo para dApp staking (solo relevante en Astar/Shibuya).\n     *         Puede ser invocado por el owner del fondo o cualquier wallet privilegiada.\n     */\n    function setDappTarget(uint256 fundId, address dapp) external {\n        Fund storage f = funds[fundId];\n        if (f.owner == address(0)) revert FundNotFound();\n        if (msg.sender != f.owner && !_isInArray(f.privileged, msg.sender))\n            revert NotOwnerOrPrivileged();\n        f.dappTarget = dapp;\n    }\n\n    // -------- Depósitos --------\n    /**\n     * @notice Depósito usando token ERC20 (p.e. cCOP en Celo). Requiere token != address(0) y aprobación previa.\n     */\n    function depositToken(uint256 fundId, uint256 amount) external {\n        Fund storage f = funds[fundId];\n        if (f.owner == address(0)) revert FundNotFound();\n        if (!f.active) revert FundNotActive();\n        if (token == address(0)) revert TokenRequired();\n        if (amount == 0) revert AmountExceedsAvailable();\n\n        //Necesita aprove previo\n        // transferFrom\n        (bool ok1, bytes memory data1) = token.call(\n            abi.encodeWithSelector(\n                bytes4(keccak256(\"transferFrom(address,address,uint256)\")),\n                msg.sender,\n                address(this),\n                amount\n            )\n        );\n        require(\n            ok1 && (data1.length == 0 || abi.decode(data1, (bool))),\n            \"ERC20 transferFrom failed\"\n        );\n\n        f.balance += amount;\n        emit Deposited(fundId, msg.sender, amount, false);\n    }\n\n    /**\n     * @notice Depósito usando moneda nativa (p.e. ASTR en Astar). Requiere token == address(0).\n     */\n    function depositNative(uint256 fundId) external payable {\n        Fund storage f = funds[fundId];\n        if (f.owner == address(0)) revert FundNotFound();\n        if (!f.active) revert FundNotActive();\n        if (msg.value == 0) revert AmountExceedsAvailable();\n\n        f.balance += msg.value;\n        emit Deposited(fundId, msg.sender, msg.value, true);\n    }\n\n    // -------- Staking (solo modo nativo / Astar) --------\n    function stakeASTR(uint256 fundId, uint128 amount) external {\n        if (token != address(0)) revert NativeRequired();\n        Fund storage f = funds[fundId];\n        if (f.owner == address(0)) revert FundNotFound();\n        if (!f.active) revert FundNotActive();\n        if (!_isInArray(f.privileged, msg.sender)) revert NotPrivileged();\n        if (f.dappTarget == address(0)) revert DappTargetNotSet();\n\n        uint256 available = f.balance - f.stakedBalance;\n        if (amount == 0 || amount > available) revert AmountExceedsAvailable();\n        if (address(this).balance < amount) revert NativeTransferFailed();\n\n        {\n            try DAppStaking(DAPPS_STAKING_V3).lock(amount) returns (bool ok) {\n                require(ok, \"lock failed\");\n            } catch Error(string memory reason) {\n                revert(string(abi.encodePacked(\"lock error: \", reason)));\n            } catch (bytes memory data) {\n                revert(_getRevertMsg(data));\n            }\n        }\n        {\n            DAppStaking.SmartContract memory target = DAppStaking\n                .SmartContract({\n                    contract_type: DAppStaking.SmartContractType.EVM,\n                    contract_address: abi.encodePacked(f.dappTarget)\n                });\n            try DAppStaking(DAPPS_STAKING_V3).stake(target, amount) returns (\n                bool ok\n            ) {\n                require(ok, \"stake failed\");\n            } catch Error(string memory reason) {\n                revert(string(abi.encodePacked(\"stake error: \", reason)));\n            } catch (bytes memory data) {\n                revert(_getRevertMsg(data));\n            }\n        }\n\n        // Contablemente movemos fondos a \"staked\"\n        f.stakedBalance += amount;\n        emit Staked(msg.sender, fundId, amount);\n    }\n\n    function endStake(uint256 fundId, uint128 amount) external {\n        if (token != address(0)) revert NativeRequired();\n        Fund storage f = funds[fundId];\n        if (f.owner == address(0)) revert FundNotFound();\n        if (!f.active) revert FundNotActive();\n        if (!_isInArray(f.privileged, msg.sender)) revert NotPrivileged();\n        if (f.dappTarget == address(0)) revert DappTargetNotSet();\n        if (amount == 0 || amount > f.stakedBalance)\n            revert AmountExceedsAvailable();\n\n        {\n            DAppStaking.SmartContract memory target = DAppStaking\n                .SmartContract({\n                    contract_type: DAppStaking.SmartContractType.EVM,\n                    contract_address: abi.encodePacked(f.dappTarget)\n                });\n            try DAppStaking(DAPPS_STAKING_V3).unstake(target, amount) returns (\n                bool ok\n            ) {\n                require(ok, \"unstake failed\");\n            } catch Error(string memory reason) {\n                revert(string(abi.encodePacked(\"unstake error: \", reason)));\n            } catch (bytes memory data) {\n                revert(_getRevertMsg(data));\n            }\n        }\n        {\n            try DAppStaking(DAPPS_STAKING_V3).unlock(amount) returns (bool ok) {\n                require(ok, \"unlock failed\");\n            } catch Error(string memory reason) {\n                revert(string(abi.encodePacked(\"unlock error: \", reason)));\n            } catch (bytes memory data) {\n                revert(_getRevertMsg(data));\n            }\n        }\n        // Contablemente reducimos el staked\n        f.stakedBalance -= amount;\n        // Por ahora no aplicamos penalización adicional aquí (puede definirse según reglas de negocio)\n        emit Unstaked(msg.sender, fundId, amount, 0);\n    }\n\n    // -------- Retiros (al cumplir tiempo) --------\n    function withdrawToBeneficiary(\n        uint256 fundId,\n        uint256 amount,\n        address to\n    ) external {\n        Fund storage f = funds[fundId];\n        if (f.owner == address(0)) revert FundNotFound();\n        if (!f.active) revert FundNotActive();\n        if (!_isInArray(f.privileged, msg.sender)) revert NotPrivileged();\n        if (block.timestamp < f.endTime) revert NotMatured();\n\n        // disponible = balance - stakedBalance (no permitir retiro de lo que sigue stakeado)\n        uint256 available = f.balance - f.stakedBalance;\n        if (amount == 0 || amount > available) revert AmountExceedsAvailable();\n\n        f.balance -= amount;\n\n        if (token == address(0)) {\n            // nativo\n            (bool sent, ) = to.call{value: amount}(\"\");\n            require(sent, \"Native transfer failed\");\n        } else {\n            // token ERC20\n            (bool ok, bytes memory data) = token.call(\n                abi.encodeWithSelector(\n                    bytes4(keccak256(\"transfer(address,uint256)\")),\n                    to,\n                    amount\n                )\n            );\n            require(\n                ok && (data.length == 0 || abi.decode(data, (bool))),\n                \"ERC20 transfer failed\"\n            );\n        }\n\n        emit Withdrawn(msg.sender, fundId, to, amount);\n    }\n\n    // -------- Utilidades --------\n    /**\n     * @notice Devuelve los IDs de fondos en los que participa el usuario\n     *         ya sea como privilegiado o beneficiario.\n     */\n    function getFundsByUser(address user) external view returns (uint256[] memory) {\n        return fundsByUser[user];\n    }\n\n    /**\n     * @notice Indica si un usuario participa en un fondo específico (privilegiado o beneficiario).\n     */\n    function isUserInFund(address user, uint256 fundId) external view returns (bool) {\n        return userInFund[user][fundId];\n    }\n    function getFund(\n        uint256 fundId\n    )\n        external\n        view\n        returns (\n            FundType fundType,\n            address owner,\n            uint64 startTime,\n            uint64 endTime,\n            address[4] memory privileged,\n            address[4] memory beneficiaries,\n            uint256 balance,\n            uint256 stakedBalance,\n            bool active\n        )\n    {\n        Fund storage f = funds[fundId];\n        if (f.owner == address(0)) revert FundNotFound();\n        return (\n            f.fundType,\n            f.owner,\n            f.startTime,\n            f.endTime,\n            f.privileged,\n            f.beneficiaries,\n            f.balance,\n            f.stakedBalance,\n            f.active\n        );\n    }\n\n    function _getRevertMsg(\n        bytes memory returnData\n    ) internal pure returns (string memory) {\n        if (returnData.length < 68) return \"call failed\";\n        assembly {\n            returnData := add(returnData, 0x04)\n        }\n        return abi.decode(returnData, (string));\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"./IDAppStaking.sol\";\r\n\r\n\r\ncontract Staking {\r\n    error NativeTransferFailed();\r\n    // Dirección del precompile DApps Staking V3 (Astar/Shibuya)\r\n    address constant DAPPS_STAKING_V3 = 0x0000000000000000000000000000000000005001;\r\n\r\n    \r\n    event Locked(address indexed user, uint128 amount);\r\n    event Staked(address indexed user, address indexed appAdress, uint128 amount);\r\n    \r\n    constructor() payable{}\r\n\r\n\r\n    function _sendTokens(address to, uint256 amount) external {\r\n        // Enviar ASTR nativa\r\n        (bool ok, ) = to.call{value: amount}(\"\");\r\n        if (!ok) revert NativeTransferFailed();\r\n    }\r\n\r\n    \r\n\r\n    function lock(uint128 amount) external{\r\n        // 1) Lock en precompile (NO requiere msg.value; la función es no payable según el interfaz)\r\n        {\r\n            try DAppStaking(DAPPS_STAKING_V3).lock(amount) returns (bool ok) {\r\n                require(ok, \"lock failed\");\r\n            } catch Error(string memory reason) {\r\n                revert(string(abi.encodePacked(\"lock error: \", reason)));\r\n            } catch (bytes memory data) {\r\n                revert(_getRevertMsg(data));\r\n            }\r\n        }\r\n\r\n        emit Locked(msg.sender, amount);\r\n    }\r\n\r\n    function stake(address appAdress, uint128 amount) external{\r\n\r\n        // 2) stake hacia el dapp target (tipo EVM)\r\n        {\r\n            DAppStaking.SmartContract memory target = DAppStaking.SmartContract({\r\n                contract_type: DAppStaking.SmartContractType.EVM,\r\n                contract_address: abi.encodePacked(appAdress)\r\n            });\r\n            try DAppStaking(DAPPS_STAKING_V3).stake(target, amount) returns (bool ok) {\r\n                require(ok, \"stake failed\");\r\n            } catch Error(string memory reason) {\r\n                revert(string(abi.encodePacked(\"stake error: \", reason)));\r\n            } catch (bytes memory data) {\r\n                revert(_getRevertMsg(data));\r\n            }\r\n        }\r\n\r\n        emit Staked(msg.sender, appAdress, amount);\r\n    }\r\n\r\n\r\n    function _getRevertMsg(bytes memory returnData) internal pure returns (string memory) {\r\n        if (returnData.length < 68) return \"call failed\";\r\n        assembly {\r\n            returnData := add(returnData, 0x04)\r\n        }\r\n        return abi.decode(returnData, (string));\r\n    }\r\n\r\n    // -------- Consultas al estado del protocolo DApp Staking --------\r\n    /// @notice Obtiene el estado actual del protocolo (era, periodo, subperiodo) desde el precompile.\r\n    /// @return era Número de era en curso\r\n    /// @return period Número de periodo en curso\r\n    /// @return subperiod Tipo de subperiodo actual (Voting, BuildAndEarn)\r\n    function getProtocolState()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 era,\r\n            uint256 period,\r\n            DAppStaking.Subperiod subperiod\r\n        )\r\n    {\r\n        DAppStaking.ProtocolState memory ps = DAppStaking(DAPPS_STAKING_V3).protocol_state();\r\n        return (ps.era, ps.period, ps.subperiod);\r\n    }\r\n\r\n}"
    },
    "contracts/StakingCelo.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport './ICeloStaking.sol';\r\n\r\ncontract StakingCelo {\r\n    CeloStakingGold private constant LOCKED_GOLD = CeloStakingGold(0x55E1A0C8f376964bd339167476063bFED7f213d5);\r\n    CeloStakingElection private constant ELECTION = CeloStakingElection(0xbD7d392BB2eF07063256E875f363d4fb2931780e);\r\n    swapcCopCelo private constant SWAP = swapcCopCelo(0xBE729350F8CdFC19DB6866e8579841188eE57f67);\r\n    cCopToken private constant CCOP = cCopToken(0x434563B0604BE100F04B7Ae485BcafE3c9D8850E);\r\n\r\n    function lock(uint256 relockAmount) external payable {\r\n        if (relockAmount > 0) {\r\n            try LOCKED_GOLD.relock(relockAmount, 0) {\r\n                return;\r\n            } catch {\r\n                if (msg.value > 0) {\r\n                    try LOCKED_GOLD.lock{value: msg.value}() {\r\n                        return;\r\n                    } catch {\r\n                        revert(\"lock failed\");\r\n                    }\r\n                } else {\r\n                    revert(\"lock failed\");\r\n                }\r\n            }\r\n        } else {\r\n            if (msg.value > 0) {\r\n                try LOCKED_GOLD.lock{value: msg.value}() {\r\n                    return;\r\n                } catch {\r\n                    revert(\"lock failed\");\r\n                }\r\n            } else {\r\n                revert(\"lock failed\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function unlock(uint256 amount) external {\r\n        LOCKED_GOLD.unlock(amount);\r\n    }\r\n\r\n    function stake(address group, uint256 value, address lesser, address greater) external {\r\n        bool ok = ELECTION.vote(group, value, lesser, greater);\r\n        require(ok, \"vote failed\");\r\n    }\r\n\r\n    function unstake(address group, uint256 value, address lesser, address greater) external {\r\n        try ELECTION.revokePending(group, value, lesser, greater, 0) returns (bool ok1) {\r\n            require(ok1, \"revokePending failed\");\r\n        } catch {\r\n            try ELECTION.revokeActive(group, value, lesser, greater, 0) returns (bool ok2) {\r\n                require(ok2, \"revokeActive failed\");\r\n            } catch {\r\n                revert(\"unstake failed\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function swap(uint256 amountIn, uint256 amountOutMin, swapcCopCelo.Step[] calldata path) external returns (uint256[] memory amounts) {\r\n        bool ok = CCOP.increaseAllowance(address(SWAP), amountIn);\r\n        require(ok, \"increaseAllowance failed\");\r\n        return SWAP.swapExactTokensForTokens(amountIn, amountOutMin, path);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}